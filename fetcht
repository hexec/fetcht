#!/usr/bin/env python3

import sys, os, re
import sqlite3, subprocess
import urllib
from urllib.request import Request, urlopen
from time import sleep
from json import dumps
from bs4 import BeautifulSoup

__version__ = '0.1'

db_path = os.getenv("HOME") + '/.local/fetcht.db'
dl_path = os.getenv("HOME")
check_pages_num = 5
torrent_client = 'deluge'
request_timeout = 30
manual_add = False

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'

    def disable(self):
        self.HEADER = ''
        self.OKBLUE = ''
        self.OKGREEN = ''
        self.WARNING = ''
        self.FAIL = ''
        self.ENDC = ''

def daemonize(name):
    """UNIX double fork mechanism."""
    try:
        pid = os.fork()
        if pid > 0:
            return # exit first parent
    except OSError as err:
        sys.stderr.write('fork #1 failed: {0}\n'.format(err))
        sys.exit(1)

    os.chdir('/') # decouple from parent environment
    os.setsid()
    os.umask(0)

    try:
        pid = os.fork() # do second fork
        if pid > 0:
            sys.exit(0) # exit from second parent
    except OSError as err:
        sys.stderr.write('fork #2 failed: {0}\n'.format(err))
        sys.exit(1)

    sys.stdout.flush() # redirect standard file descriptors
    sys.stderr.flush()
    si = open(os.devnull, 'r')
    so = open(os.devnull, 'a+')
    se = open(os.devnull, 'a+')

    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())
    os.spawnlp(os.P_NOWAIT, name, name)

def check_process(name):
    ps= subprocess.Popen("ps -A | awk '/" + name + "/{print \"1\";exit}'",
                          shell=True, stdout=subprocess.PIPE)
    output = ps.stdout.read()
    ps.stdout.close()
    ps.wait()
    if  output != b'1\n':
        load_process(name);
        check_process(name);
    else:
        print("*** Process {0} is running!".format(name));
    
def load_process(name):
    print("*** process not running, loading {0}!".format(name))
    daemonize(name)
    sleep(1)

def execute(command):
    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE);
    output, errors = p.communicate();
    return str(output.decode("ascii"));

def load_magnet(magnet):
    execute("({0} \"{1}\") > /dev/null".format(torrent_client, magnet));
    return True

def download_file(url, filename):
    try:
        with urllib.request.urlopen(url) as response, open(os.getenv("HOME") + '/' + filename, 'wb') as outf:
            outf.write(response.read());
            outf.close();
    except Exception as e:
        print(bcolors.FAIL + "Error downloading file: " + bcolors.ENDC + e.args[0]);
        pass;
        return False

    return True

def ask(what):
    res = input("{0} (y/N) ".format(what))
    if res == "yes" or res == "y":
      return True
    else:
      return False

def find_name_by_id(cur, id):
    cur.execute("SELECT name FROM keyword WHERE id={0}".format(id));
    res = cur.fetchone();
    return res[0];

# use like
def find_id_by_name(cur, name):
    cur.execute("SELECT id FROM keyword WHERE name={0}".format(name));
    res = cur.fetchone();
    return res[0];

def check_filter(cur, id, item):
    ret=True; # download file
    skip=True;
    count=0;
    for row_include in cur.execute("SELECT value FROM filter WHERE id={0} AND exclude=0".format(str(id))):
        count+=1;
        if item.find(row_include[0]) > 0:
            skip=False;

    if count!=0 and skip:
        print(bcolors.WARNING + "filtering out:\n" + bcolors.ENDC + "{0}. include reason not found.\n".format(item));
        ret=False;
    else:
        skip=False;
    for row_exclude in cur.execute("SELECT value FROM filter WHERE id={0} AND exclude=1".format(str(id))):
        if row_exclude[0] in item:
            skip=True;
    if skip:
        print(bcolors.WARNING + "filtering out:\n" + bcolors.ENDC + "{0}. exclude reason.\n".format(item));
        ret=False;

    return ret;

def check_memory(cur, item):
    count=0;
    for row in cur.execute("SELECT * FROM memory WHERE value = '{0}'".format(str(item))):
        count+=1;
    if count == 0:
        print(bcolors.OKBLUE + "new torrent found:\n" + bcolors.ENDC + "{0}\n".format(str(item)));
        return True
    else:
        print(bcolors.WARNING + "torrent already downloaded:\n" + bcolors.ENDC + "{0}\n".format(str(item)));
        return False

def add_to_memory(cur, item):
    cur.execute("INSERT INTO memory VALUES (NULL, '{0}', strftime('%s','now'))".format(str(item)));
    con.commit();

def process_torrent(cur, item, url):
    if check_memory(cur, item):
        if manual_add and (not ask("Do you want to load this torrent?")):
            return

        ret = False;
        if url == "":
            ret = load_magnet(item);
        else:
            ret = download_file(url, item + ".torrent")

        if ret:
            add_to_memory(cur, item);

################################################################################

if __name__ == '__main__':
    print("fecht v{0} (hex0var) GPLv2".format(__version__))

    con=sqlite3.connect(db_path)
    cur=con.cursor()

    find_name_by_id(cur, 1)

    while True:
        cmd = ""
        if len(sys.argv) > 1:
            cmd = sys.argv[1:]
        else:
            raw = input("> ")
            cmd = raw.split(" ")

        c = cmd[0]

        if c == "exit" or c == "quit" or c == "e" or c == "q":
            break

        elif c == "help" or c == "h" or c == "?":
            print('''quit/exit                - exit program
init                     - init database
dump                     - backup database to sql file
insert  <name> (src)     - insert a new download item
delete  <name>           - delete name from db
update  <id> <opt> <val> -
enable  <id>             -
disable <id>             -
filter  <id>             -
filter  <id> <val> <0/1> -
clear                    - clear downloaded memory
fetch                    - fetch torrent magnets
list                     - list watched keywords''')
        elif c == "init":
            if ask("Are you sure?"):
                try:
                    cur.execute('''CREATE TABLE keyword
                                   (id INTEGER,
                                    name TEXT,
                                    date TEXT,
                                    source TEXT,
                                    enabled BOOLEAN,
                                    PRIMARY KEY (id),
                                    UNIQUE (name))''')
                    cur.execute('''CREATE TABLE memory
                                   (id INTEGER,
                                    value TEXT,
                                    date  INTEGER,
                                    PRIMARY KEY (id,value))''')
                    cur.execute('''CREATE TABLE filter
                                   (id INTEGER,
                                    value TEXT,
                                    exclude BOOLEAN,
                                    PRIMARY KEY (id,value,exclude))''')
                    con.commit();
                except sqlite3.Error as e:
                    print(e.args[0])
        elif c == "insert" or c == "ins" or c == "i":
            if len(cmd) >= 2:
                try:
                    if len(cmd) == 2:
                        cur.execute("INSERT INTO keyword VALUES (NULL, '{0}', datetime('now'), "", 1)".format(str(cmd[1])));
                        con.commit();
                        print("inserting \"{0}\" source: default".format(cmd[1]));
                    elif len(cmd) == 3:
                        cur.execute("INSERT INTO keyword VALUES (NULL, '{0}', datetime('now'), '{1}', 1)".format(str(cmd[1]), str(cmd[2])));
                        con.commit();
                        print("inserting \"{0}\" source: {1}".format(cmd[1],cmd[2]));
                    else:
                        print("too many arguments!");
                except sqlite3.Error as e:
                    print(e.args[0])
            else:
                print("wrong synthax. use \"insert <name> (source)\"");
        elif c == "update" or c == "up" or c == "u":
            if len(cmd) == 4:
                try:
                    cur.execute("UPDATE keyword SET {1}='{2}' WHERE id={0}".format(str(cmd[1]), str(cmd[2])), str(cmd[3]));
                    con.commit();
                    print("updating id \"{0}\".{1} = {2}".format(cmd[1],cmd[2],cmd[3]));
                except sqlite3.Error as e:
                    print(e.args[0])
            else:
                print("wrong synthax. use \"update <id> <opt> <val>\"");
                print("<opt>: name, enable, source\"");
        elif c == "filter":
            if len(cmd) == 2:
                try:
                    print("Filters for {0}:".format(find_name_by_id(cur, cmd[1])));
                    for row in cur.execute("SELECT value,exclude FROM filter WHERE id={0}".format(str(cmd[1]))):
                        print("{0} exclude:{1}".format(row[0], row[1]))
                except sqlite3.Error as e:
                    print(e.args[0])
            elif len(cmd) == 4:
                try:
                    cur.execute("INSERT INTO filter VALUES ('{0}', '{1}' , {2})".format(str(cmd[1]), str(cmd[2]), str(cmd[3])));
                    con.commit();
                    print("new filter for id \"{0}\" keyword: \"{1}\" exclude: {2}".format(cmd[1],cmd[2],cmd[3]));
                except sqlite3.Error as e:
                    print(e.args[0])
            else:
                print("wrong synthax. use \"filter <id> <val> <0/1>\"");
        elif c == "delete" or c == "del" or c ==  "d":
            if len(cmd) == 2:
                try:
                    cur.execute("DELETE FROM keyword WHERE id={0}".format(cmd[1].lower()))
                    cur.execute("DELETE FROM memory WHERE id={0}".format(cmd[1].lower()))
                    cur.execute("DELETE FROM filter WHERE id={0}".format(cmd[1].lower()))
                    con.commit();
                    print("deleting id \"{0}\" done".format(cmd[1]));
                except sqlite3.Error as e:
                    print(e.args[0])
            else:
                print("wrong synthax. use \"delete <id>\"")
        elif c == "list" or c == "lst" or c == "l": # tabulate and show EXCLUDE{...}, INCLUDE{...}
            try:
                for row in cur.execute('SELECT id,name,enabled,source FROM keyword ORDER BY name'):
                    if row[2]:
                        print("{1}\tid:{0} source: {2}".format(row[0], row[1], row[3]))
                    else:
                        print("{1}\tid:{0} source: {2} DISABLED".format(row[0], row[1], row[3]))
            except sqlite3.Error as e:
                print(e.args[0])
        elif c == "clear" or c == "clr":
            try:
                cur.execute('DELETE FROM memory');
                con.commit();
                print("memory table cleared");
            except sqlite3.Error as e:
                print(e.args[0])

        elif c == "fetch" or c == "f":
            check_process(torrent_client);
            if len(cmd) > 1 and cmd[1] == "manual":
                manual_add = True;
            if len(cmd) > 1 and cmd[1].isdigit():
                check_pages_num = int(cmd[1])

            print("checking eztv source...");
            for i in range(0, check_pages_num):
                print("page #{0}".format(i));
                try:
                    eztv_url = "http://eztv.it/"; #'https://eztv.ch/', 'https://eztv-proxy.net/'
                    if i > 0:
                        eztv_url = "{0}page_{1}".format(eztv_url,i);

                    req = Request(eztv_url, headers={'User-Agent': 'Mozilla/5.0'});
                    data = urlopen(req, None, request_timeout).read();
                    regexp = re.compile("<a href=\"(magnet.+?)\"");
                    magnets = regexp.findall(str(data));
                    try:
                        for m in magnets:
                            m = m.strip()
                            for row in cur.execute('SELECT id,name FROM keyword WHERE enabled=1 AND source="eztv" ORDER BY name'):
                                if m.find(row[1]) > 0 :
                                    if check_filter(cur, row[0], m):
                                        process_torrent(cur, m, "");
                    except Exception as e:
                        print(e.args[0])
                        pass
                except Exception as e:
                    print(e.args[0])
                    pass

            print("checking nyaa source...");
            nyaa_url = "http://www.nyaa.se/?page=search&cats=1_37&offset="
            for page in range(1, check_pages_num + 1):
                print("page #" + str(page-1))
                try:
                    req = Request(nyaa_url + str(page), headers={'User-Agent': 'Mozilla/5.0'})
                    data = urlopen(req, None, request_timeout).read()
                    soup = BeautifulSoup(data, "lxml")
                    soup = soup.find("table", {"class": "tlist"})
                    for elem in soup.find_all("td", {"class", "tlistname"}):
                        link = elem.find("a")
                        name = link.get_text()
                        download_url = str(link.get('href')).replace("page=view", "page=download").replace("//www", "http://www")
                        try:
                            for row in cur.execute('SELECT id, name FROM keyword WHERE enabled=1 AND source="nyaa" ORDER BY name'):
                                if row[1] in name:
                                    if check_filter(cur, row[0], row[1]):
                                        process_torrent(cur, name, download_url);
                        except Sqlite3.error as e:
                            print(e.args[0])
                            #pass
                except Exception as e:
                    print(e.args[0])
                    pass
            break;
            print("checking showrss source..."); #TODO to be finished
            showrss_url = "http://showrss.info/other/all.rss"
            for page in range(1, check_pages_num + 1):
                print("page #" + str(page-1))
                try:
                    req = Request(showrss_url + str(page), headers={'User-Agent': 'Mozilla/5.0'})
                    data = urlopen(req, None, request_timeout).read()
                    soup = BeautifulSoup(data, "lxml")
                    soup = soup.find("item")
                    for elem in soup.find_all("link"):
                        link = ""
                except Exception as e:
                    print(e.arge[0])
                    pass
        else:
            print("type \"help\" for command list")
        if len(sys.argv) > 1:
           break
    cur.execute("DELETE FROM memory WHERE (strftime('%s','now') - date) > 15552000") # 6 months
    con.commit();
    con.close()
